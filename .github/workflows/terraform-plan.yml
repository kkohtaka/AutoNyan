---
name: Terraform Plan

run-name: |
  ${{
    github.event_name == 'issue_comment' &&
    format('Manual Plan - PR #{0} ({1})', github.event.issue.number, github.event.comment.user.login) ||
    github.event_name == 'workflow_dispatch' && inputs.pr_number &&
    format('Auto Plan - PR #{0} ({1})', inputs.pr_number, inputs.pr_ref) ||
    github.event_name == 'workflow_dispatch' &&
    format('Auto Plan - {0} ({1})', github.ref_name, github.sha) ||
    'Terraform Plan'
  }}

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull request number (for auto-triggered runs)'
        required: false
        type: number
      pr_ref:
        description: 'Git ref from PR (for auto-triggered runs)'
        required: false
        type: string
      pr_sha:
        description: 'Git SHA from PR (for auto-triggered runs)'
        required: false
        type: string

permissions:
  contents: read
  pull-requests: write
  id-token: write
  statuses: write
  actions: write

concurrency:
  # Use the same concurrency group as deploy to ensure mutual exclusion.
  # Plan and Apply both acquire the same Terraform state lock in GCS,
  # so only one operation (plan OR apply) can run at a time.
  # The composite key also ensures environment-level deployment serialization.
  group: terraform-production
  cancel-in-progress: false

jobs:
  terraform-plan:
    if: |
      (github.event_name == 'issue_comment' &&
       github.event.issue.pull_request &&
       contains(github.event.comment.body, '/terraform plan') &&
       (github.event.comment.author_association == 'OWNER' ||
        github.event.comment.author_association == 'MEMBER' ||
        github.event.comment.author_association == 'COLLABORATOR')) ||
      (github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      NODE_OPTIONS: --max-old-space-size=4096

    steps:
      - name: Get PR details
        id: pr
        uses: actions/github-script@v8
        with:
          script: |
            if (context.eventName === 'issue_comment') {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });
              return {
                ref: pr.head.ref,
                sha: pr.head.sha,
                repo: pr.head.repo.full_name,
                number: context.issue.number
              };
            } else if (context.eventName === 'workflow_dispatch') {
              const inputs = context.payload.inputs;
              if (inputs.pr_number) {
                // Auto-triggered from Test workflow with PR info
                return {
                  ref: inputs.pr_ref,
                  sha: inputs.pr_sha,
                  repo: context.repo.full_name,
                  number: parseInt(inputs.pr_number)
                };
              } else {
                // Manual dispatch or push to master
                return {
                  ref: context.ref.replace('refs/heads/', ''),
                  sha: context.sha,
                  repo: context.repo.full_name,
                  number: null
                };
              }
            }

      - name: Comment acknowledgment for manual trigger
        if: github.event_name == 'issue_comment'
        uses: actions/github-script@v8
        with:
          script: |
            const prDetails = ${{ steps.pr.outputs.result }};
            const issueNumber = prDetails.number;

            await github.rest.issues.createComment({
              issue_number: issueNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `üöÄ **Terraform Plan Started**\n\n` +
                    `Triggered by @${{ github.event.comment.user.login }} with command: \`/terraform plan\`\n\n` +
                    `Plan execution is now running... Check the ` +
                    `[workflow run](${{ github.server_url }}/${{ github.repository }}/` +
                    `actions/runs/${{ github.run_id }}) for progress.`
            });

      - name: Set status to pending
        uses: actions/github-script@v8
        with:
          script: |
            const prDetails = ${{ steps.pr.outputs.result }};
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: prDetails.sha,
              state: 'pending',
              context: 'terraform/plan',
              description: 'Terraform plan is running...',
              target_url: `${context.serverUrl}/${context.repo.owner}/` +
                          `${context.repo.repo}/actions/runs/${context.runId}`
            });

      - name: Checkout PR code
        uses: actions/checkout@v6
        with:
          ref: ${{ fromJson(steps.pr.outputs.result).sha }}
          fetch-depth: 0

      - name: Detect if Terraform plan is needed
        id: detect
        run: |
          # For PRs, compare against master branch
          # For master pushes, check the changed files in the commit
          if [ -n "${{ inputs.pr_number }}" ]; then
            # This is a PR - fetch master and compare
            git fetch origin master:master
            CHANGED_FILES=$(git diff --name-only master...${{ fromJson(steps.pr.outputs.result).sha }})
          else
            # This is a push to master - check the commit changes
            if git rev-parse HEAD^ >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only HEAD^..HEAD)
            else
              # Initial commit: diff against empty tree
              # All files will be considered "changed" in this scenario.
              # The workflow will filter by file patterns below to avoid
              # unnecessary Terraform plans for documentation-only repos.
              CHANGED_FILES=$(git diff --name-only $(git hash-object -t tree /dev/null)..HEAD)
            fi
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Check if any changed files affect Terraform
          # Patterns that require terraform plan:
          # - terraform/** (infrastructure config)
          # - src/** (function source code)
          # - package.json / package-lock.json (dependencies)
          # - scripts/build-function.sh (build process)
          PATTERN='(^|/)(terraform/|src/|package\.json|package-lock\.json|scripts/build-function\.sh)'
          if echo "$CHANGED_FILES" | grep -qE "$PATTERN"; then
            echo "needs_terraform=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Terraform-related files changed - will run plan"
          else
            echo "needs_terraform=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è  No infrastructure files changed - skipping plan"
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Setup Terraform
        if: steps.detect.outputs.needs_terraform == 'true'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.0'

      - name: Authenticate to Google Cloud
        if: steps.detect.outputs.needs_terraform == 'true'
        uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}

      - name: Setup Terraform backend
        if: steps.detect.outputs.needs_terraform == 'true'
        run: npm run setup:terraform-backend
        env:
          TF_STATE_BUCKET: ${{ vars.TF_STATE_BUCKET }}
          TF_STATE_LOCATION: ${{ vars.TF_STATE_LOCATION }}

      - name: Generate terraform.tfvars
        if: steps.detect.outputs.needs_terraform == 'true'
        run: npm run setup:terraform-variables
        env:
          GCP_REGION: ${{ vars.TF_STATE_LOCATION }}
          DRIVE_FOLDER_ID: ${{ secrets.DRIVE_FOLDER_ID }}
          DRIVE_SCANNER_SCHEDULE: ${{ vars.DRIVE_SCANNER_SCHEDULE }}

      - name: Run Terraform plan
        if: steps.detect.outputs.needs_terraform == 'true'
        id: plan
        run: |
          npm run build:function
          npm run terraform:init
          npm run terraform:plan 2>&1 | tee plan_output.txt
          PLAN_EXIT_CODE=${PIPESTATUS[0]}
          echo "plan_exit_code=${PLAN_EXIT_CODE}" >> $GITHUB_OUTPUT
          exit ${PLAN_EXIT_CODE}

      - name: Skip Terraform plan (no relevant changes)
        if: steps.detect.outputs.needs_terraform == 'false'
        id: skip
        run: |
          echo "plan_exit_code=0" >> $GITHUB_OUTPUT
          echo "‚è≠Ô∏è  Skipping Terraform plan - no infrastructure files changed" | tee plan_output.txt
          echo "" >> plan_output.txt
          echo "This PR only modifies files that do not affect infrastructure." >> plan_output.txt
          echo "No Terraform plan is required." >> plan_output.txt

      - name: Comment PR with plan results
        if: steps.pr.outputs.result && fromJson(steps.pr.outputs.result).number != null
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const planOutput = fs.readFileSync('plan_output.txt', 'utf8');
            const exitCode = '${{ steps.plan.outputs.plan_exit_code || steps.skip.outputs.plan_exit_code }}';
            const wasSkipped = '${{ steps.detect.outputs.needs_terraform }}' === 'false';

            const success = exitCode === '0';
            const emoji = wasSkipped ? '‚è≠Ô∏è' : (success ? '‚úÖ' : '‚ùå');
            const status = wasSkipped ? 'SKIPPED' : (success ? 'SUCCESS' : 'FAILED');

            const triggerInfo = context.eventName === 'issue_comment'
              ? `*Triggered by comment from @${{ github.event.comment.user.login }}*`
              : `*Auto-triggered after Test workflow success*`;

            const prDetails = ${{ steps.pr.outputs.result }};
            const issueNumber = prDetails.number;

            const body = wasSkipped
              ? `## ${emoji} Terraform Plan ${status}

            No infrastructure-related files were changed in this PR.

            ${planOutput}

            ${triggerInfo}`
              : `## ${emoji} Terraform Plan ${status}

            <details>
            <summary>Click to expand plan output</summary>

            \`\`\`
            ${planOutput}
            \`\`\`
            </details>

            ${triggerInfo}`;

            github.rest.issues.createComment({
              issue_number: issueNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Set final status
        if: always()
        uses: actions/github-script@v8
        with:
          script: |
            const prDetails = ${{ steps.pr.outputs.result }};
            const exitCode = '${{ steps.plan.outputs.plan_exit_code || steps.skip.outputs.plan_exit_code }}';
            const wasSkipped = '${{ steps.detect.outputs.needs_terraform }}' === 'false';
            const success = exitCode === '0';

            const state = success ? 'success' : 'failure';
            const description = wasSkipped
              ? 'Terraform plan skipped (no infrastructure changes)'
              : (success
                ? 'Terraform plan completed successfully'
                : 'Terraform plan failed');

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: prDetails.sha,
              state: state,
              context: 'terraform/plan',
              description: description,
              target_url: `${context.serverUrl}/${context.repo.owner}/` +
                          `${context.repo.repo}/actions/runs/${context.runId}`
            });

            if (!success) {
              core.setFailed('Terraform plan failed');
            }

      - name: Cleanup Terraform lock on failure
        if: failure() && steps.detect.outputs.needs_terraform == 'true' && steps.plan.conclusion == 'failure'
        run: |
          echo "üßπ Cleaning up potential stale lock due to Terraform failure..."
          echo "‚ÑπÔ∏è  Concurrency group ensures no other Terraform operations are running"

          LOCK_FILE="gs://${{ vars.TF_STATE_BUCKET }}/terraform/state/default.tflock"

          # Note: Using 'gcloud storage' instead of 'gsutil' because gsutil does not
          # support Workload Identity Federation credentials. See:
          # https://github.com/google-github-actions/auth#authenticating-via-workload-identity-federation
          if gcloud storage ls "${LOCK_FILE}" 2>/dev/null; then
            echo "üîì Lock file found. Attempting to unlock..."

            # Get lock file content and extract lock ID
            LOCK_CONTENT=$(gcloud storage cat "${LOCK_FILE}" 2>/dev/null || echo "")

            if [ -n "$LOCK_CONTENT" ]; then
              LOCK_ID=$(echo "$LOCK_CONTENT" | jq -r '.ID // empty')

              if [ -n "$LOCK_ID" ]; then
                echo "Lock ID: ${LOCK_ID}"
                echo "Using terraform force-unlock..."

                if terraform -chdir=terraform force-unlock -force "${LOCK_ID}"; then
                  echo "‚úÖ Lock cleanup completed"
                else
                  echo "‚ö†Ô∏è  terraform force-unlock failed"
                fi
              else
                echo "‚ö†Ô∏è  Could not extract lock ID from lock file"
                echo "Using gcloud storage rm as fallback..."
                gcloud storage rm "${LOCK_FILE}" && echo "‚úÖ Lock cleanup completed" || echo "‚ö†Ô∏è  Failed to remove lock file"
              fi
            else
              echo "‚ö†Ô∏è  Lock file is empty, using gcloud storage rm..."
              gcloud storage rm "${LOCK_FILE}" && echo "‚úÖ Lock cleanup completed" || echo "‚ö†Ô∏è  Failed to remove lock file"
            fi
          else
            echo "‚ÑπÔ∏è  No lock file found (already unlocked)"
          fi

      - name: Trigger Deploy workflow (master branch only)
        if: |
          steps.detect.outputs.needs_terraform == 'true' &&
          steps.plan.outputs.plan_exit_code == '0' &&
          github.event_name == 'workflow_dispatch' &&
          fromJson(steps.pr.outputs.result).ref == 'master'
        uses: actions/github-script@v8
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'deploy.yml',
              ref: context.ref,
              inputs: {
                deploy_ref: context.ref
              }
            });

            console.log(`Triggered Deploy workflow for ref ${context.ref}`);
