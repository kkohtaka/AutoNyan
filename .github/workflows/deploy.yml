---
name: Deploy

run-name: Deploy to Production (${{ inputs.deploy_ref }})

on:
  workflow_dispatch:
    inputs:
      deploy_ref:
        description: 'Git ref to deploy'
        required: true
        type: string

permissions:
  contents: read
  id-token: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment:
      name: production
    concurrency:
      # Use the same concurrency group as plan to ensure mutual exclusion.
      # Plan and Apply both acquire the same Terraform state lock in GCS,
      # so only one operation (plan OR apply) can run at a time.
      # The composite key also ensures environment-level deployment serialization.
      group: terraform-production
      cancel-in-progress: false
    env:
      NODE_OPTIONS: --max-old-space-size=4096

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.deploy_ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.0'

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}

      - name: Setup Terraform backend
        run: npm run setup:terraform-backend
        env:
          TF_STATE_BUCKET: ${{ vars.TF_STATE_BUCKET }}
          TF_STATE_LOCATION: ${{ vars.TF_STATE_LOCATION }}

      - name: Generate terraform.tfvars
        run: npm run setup:terraform-variables
        env:
          GCP_REGION: ${{ vars.TF_STATE_LOCATION }}
          DRIVE_FOLDER_ID: ${{ secrets.DRIVE_FOLDER_ID }}
          DRIVE_SCANNER_SCHEDULE: ${{ vars.DRIVE_SCANNER_SCHEDULE }}
          CATEGORY_ROOT_FOLDER_ID: ${{ secrets.CATEGORY_ROOT_FOLDER_ID }}
          UNCATEGORIZED_FOLDER_ID: ${{ secrets.UNCATEGORIZED_FOLDER_ID }}

      - name: Deploy infrastructure
        id: deploy
        run: |
          npm run terraform:init
          npm run terraform:apply 2>&1 | tee deploy_output.txt
          echo "deploy_exit_code=${PIPESTATUS[0]}" >> $GITHUB_OUTPUT

      - name: Report deployment status
        if: always()
        run: |
          EXIT_CODE="${{ steps.deploy.outputs.deploy_exit_code }}"
          if [ "$EXIT_CODE" = "0" ]; then
            echo "‚úÖ Deployment to production completed successfully"
            echo "Deployed ref: ${{ inputs.deploy_ref }}"
          else
            echo "‚ùå Deployment to production failed"
            echo "Deploy ref: ${{ inputs.deploy_ref }}"
            exit 1
          fi

      - name: Cleanup Terraform lock on failure
        if: failure() && steps.deploy.conclusion == 'failure'
        run: |
          echo "üßπ Cleaning up potential stale lock due to Terraform failure..."
          echo "‚ÑπÔ∏è  Concurrency group ensures no other Terraform operations are running"

          LOCK_FILE="gs://${{ vars.TF_STATE_BUCKET }}/terraform/state/default.tflock"

          if gsutil ls "${LOCK_FILE}" 2>/dev/null; then
            echo "üîì Lock file found. Attempting to unlock..."

            # Get lock file content and extract lock ID
            LOCK_CONTENT=$(gsutil cat "${LOCK_FILE}" 2>/dev/null || echo "")

            if [ -n "$LOCK_CONTENT" ]; then
              LOCK_ID=$(echo "$LOCK_CONTENT" | jq -r '.ID // empty')

              if [ -n "$LOCK_ID" ]; then
                echo "Lock ID: ${LOCK_ID}"
                echo "Using terraform force-unlock..."

                if terraform -chdir=terraform force-unlock -force "${LOCK_ID}"; then
                  echo "‚úÖ Lock cleanup completed"
                else
                  echo "‚ö†Ô∏è  terraform force-unlock failed"
                fi
              else
                echo "‚ö†Ô∏è  Could not extract lock ID from lock file"
                echo "Using gsutil rm as fallback..."
                gsutil rm "${LOCK_FILE}" && echo "‚úÖ Lock cleanup completed" || echo "‚ö†Ô∏è  Failed to remove lock file"
              fi
            else
              echo "‚ö†Ô∏è  Lock file is empty, using gsutil rm..."
              gsutil rm "${LOCK_FILE}" && echo "‚úÖ Lock cleanup completed" || echo "‚ö†Ô∏è  Failed to remove lock file"
            fi
          else
            echo "‚ÑπÔ∏è  No lock file found (already unlocked)"
          fi
