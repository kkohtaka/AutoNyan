---
name: Deploy

run-name: |
  ${{
    github.event_name == 'push' &&
    format('Deploy to Production ({0})', github.ref_name) ||
    format('Deploy to {0} ({1})', inputs.environment, inputs.deploy_ref)
  }}

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+' # semver tags trigger production deployment
  workflow_dispatch:
    inputs:
      deploy_ref:
        description: 'Git ref to deploy'
        required: true
        type: string
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging

permissions:
  contents: read
  id-token: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment:
      name: ${{ github.event_name == 'push' && 'production' || inputs.environment }}
    concurrency:
      # Use environment-specific concurrency group to ensure mutual exclusion.
      # Plan and Apply both acquire the same Terraform state lock in GCS,
      # so only one operation (plan OR apply) can run at a time per environment.
      group: terraform-${{ github.event_name == 'push' && 'production' || inputs.environment }}
      cancel-in-progress: false
    env:
      NODE_OPTIONS: --max-old-space-size=4096
      DEPLOY_ENV: ${{ github.event_name == 'push' && 'production' || inputs.environment }}
      DEPLOY_REF: ${{ github.event_name == 'push' && github.ref || inputs.deploy_ref }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          ref: ${{ env.DEPLOY_REF }}

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build function packages
        run: npm run build:function

      - name: Validate function packages
        run: npm run validate:function

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.8.5'

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}

      - name: Setup Terraform backend
        run: npm run setup:terraform-backend
        env:
          TF_STATE_BUCKET: ${{ vars.TF_STATE_BUCKET }}
          TF_STATE_LOCATION: ${{ vars.TF_STATE_LOCATION }}
          ENVIRONMENT: ${{ env.DEPLOY_ENV }}

      - name: Generate terraform.tfvars
        run: npm run setup:terraform-variables
        env:
          ENVIRONMENT: ${{ env.DEPLOY_ENV }}
          GCP_REGION: ${{ vars.TF_STATE_LOCATION }}
          DRIVE_FOLDER_ID: ${{ secrets.DRIVE_FOLDER_ID }}
          DRIVE_SCANNER_SCHEDULE: ${{ vars.DRIVE_SCANNER_SCHEDULE }}
          CATEGORY_ROOT_FOLDER_ID: ${{ secrets.CATEGORY_ROOT_FOLDER_ID }}
          UNCATEGORIZED_FOLDER_ID: ${{ secrets.UNCATEGORIZED_FOLDER_ID }}

      - name: Deploy infrastructure
        id: deploy
        run: |
          npm run terraform:init
          npm run terraform:apply 2>&1 | tee deploy_output.txt
          echo "deploy_exit_code=${PIPESTATUS[0]}" >> $GITHUB_OUTPUT

      - name: Report deployment status
        if: always()
        run: |
          EXIT_CODE="${{ steps.deploy.outputs.deploy_exit_code }}"
          if [ "$EXIT_CODE" = "0" ]; then
            echo "‚úÖ Deployment to ${{ env.DEPLOY_ENV }} completed successfully"
            echo "Deployed ref: ${{ env.DEPLOY_REF }}"
          else
            echo "‚ùå Deployment to ${{ env.DEPLOY_ENV }} failed"
            echo "Deploy ref: ${{ env.DEPLOY_REF }}"
            exit 1
          fi

      - name: Cleanup Terraform lock on failure
        if: failure() && steps.deploy.conclusion == 'failure'
        run: |
          echo "üßπ Cleaning up potential stale lock due to Terraform failure..."
          echo "‚ÑπÔ∏è  Concurrency group ensures no other Terraform operations are running"

          LOCK_FILE="gs://${{ vars.TF_STATE_BUCKET }}/terraform/state/${{ env.DEPLOY_ENV }}/default.tflock"

          # Note: Using 'gcloud storage' instead of 'gsutil' because gsutil does not
          # support Workload Identity Federation credentials.
          if gcloud storage ls "${LOCK_FILE}" 2>/dev/null; then
            echo "üîì Lock file found. Removing..."

            # Display lock info for debugging
            LOCK_CONTENT=$(gcloud storage cat "${LOCK_FILE}" 2>/dev/null || echo "")
            if [ -n "$LOCK_CONTENT" ]; then
              LOCK_ID=$(echo "$LOCK_CONTENT" | jq -r '.ID // empty')
              echo "Lock ID: ${LOCK_ID}"
            fi

            # Note: The GCS backend uses UUID-format lock IDs, but 'terraform force-unlock'
            # expects numerical lock IDs. Therefore, we delete the lock file directly.
            if gcloud storage rm "${LOCK_FILE}"; then
              echo "‚úÖ Lock cleanup completed"
            else
              echo "‚ö†Ô∏è  Failed to remove lock file"
            fi
          else
            echo "‚ÑπÔ∏è  No lock file found (already unlocked)"
          fi
